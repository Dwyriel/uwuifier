#include <iostream>
#include <filesystem>
#include <fstream>

#include "cmake_config.h"

#include "DArgumentParser.h"

const uint64_t defaultSeed = 0xA57FB9E013C2D486;
const uint8_t maxSeedStringSize = 16;
const char hexDigits[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
#if UWUIFIED
const char *helpDescription = "Pwints this message.";
const char *versionDescription = "Pwints the vewsion.";
const char *inputDescription = "Fiwe to be UwUified. No need to pass [text] if set.";
const char *outputDescription = "Fiwe to save the output to.";
const char *seedDescription = "Seed to be used when wandomizing.";
const char *forceOutputDescription = "Fowces output fiwe to be ovew-wwitten if it aw-weady exists.";
#else
const char *helpDescription = "Prints this message.";
const char *versionDescription = "Prints the version.";
const char *inputDescription = "File to be UwUified. No need to pass [text] if set.";
const char *outputDescription = "File to save the output to.";
const char *seedDescription = "Seed to be used when randomizing.";
const char *forceOutputDescription = "Forces output file to be overwritten if it already exists.";
#endif

bool isValidHexNumber(const std::string &str) {
    auto isHexDigit = [](char c) {
        for (char hexDigit: hexDigits)
            if (hexDigit == c)
                return true;
        return false;
    };
    for (char c: str)
        if (!isHexDigit(c))
            return false;
    return true;
}

uint64_t convertToSeedFromHex(const std::string &str) {
    uint64_t seed = std::stoull(str, nullptr, 16);
    return seed;
}

std::string convertToStringAsHex(uint64_t seed) {
    std::string str(maxSeedStringSize, hexDigits[0]);
    for (int str_i = maxSeedStringSize - 1, hex_i = 0; str_i >= 0; --str_i, ++hex_i)
        str[str_i] = hexDigits[(seed >> (hex_i * 4) & 0x000000000000000F)];
    return str;
}

/**
 * @attention irreversible if \<str> was not previous generated by \<convertToString> function.
 */
uint64_t convertToSeed(const std::string &str) {
    uint64_t seed = 0;
    for (int i = 0; i < str.size(); ++i)
        seed = (((uint64_t) (((unsigned char) (str[i] - 1)) % 16)) << i * 4) | seed;//reducing one to be able to revert back to string when using convertToString
    return seed;
}

/**
 * @attention might not restore original string.
 */
std::string convertToString(uint64_t seed) {
    std::string str(maxSeedStringSize, '\0');
    for (int i = 0; i < maxSeedStringSize; ++i)
        str[i] = (char) ((seed >> (i * 4) & 0x000000000000000F) + 97);//97 = 'a' character
    return str;
}

/**
 * @return tuple containing:
 * @return 0 {std::string} : text to be uwuified
 * @return 1 {uint64_t} : seed to be used in rng engine
 * @return 2 {std::string} : output file name, empty if not set
 */
auto parseArgs(int argc, char **argv) {
    auto fileError = [](const std::filesystem::path &path, const char *message) {
        std::cout << path << ' ' << message << '\n';
        exit(EXIT_FAILURE);
    };
    DArgumentOption helpOption(DArgumentOptionType::HelpOption, {'h'}, {"help", "hewp"}, helpDescription);
    DArgumentOption versionOption(DArgumentOptionType::VersionOption, {'v'}, {"version", "vewsion"}, versionDescription);
    DArgumentOption inputOption(DArgumentOptionType::InputOption, {'i'}, {"input"}, inputDescription);
    DArgumentOption outputOption(DArgumentOptionType::InputOption, {'o'}, {"output"}, outputDescription);
    DArgumentOption forceOutputOption(DArgumentOptionType::NormalOption, {'f'}, {"force", "fowce"}, forceOutputDescription);
    DArgumentOption seedOption(DArgumentOptionType::InputOption, {'s'}, {"seed"}, seedDescription);
    DArgumentParser parser(argc, argv, PROJECT_NAME, PROJECT_VER);
    parser.AddArgumentOption({&helpOption, &versionOption, &inputOption, &outputOption, &forceOutputOption, &seedOption});
    parser.AddPositionalArgument("text", "Text(s) to be uwuified", "[text...]");
    auto result = parser.Parse();
    if (result != DParseResult::ParseSuccessful) {
        std::cout << parser.ErrorText() << "\n\n" << parser.HelpText();
        exit(EXIT_FAILURE);
    }
    if (helpOption.WasSet() || versionOption.WasSet()) {
        if (versionOption.WasSet())
            std::cout << parser.VersionText();
        if (helpOption.WasSet())
            std::cout << parser.HelpText();
        exit(EXIT_SUCCESS);
    }
    std::string outputFile = outputOption.GetValue();
    if (outputOption.WasSet()) {
        std::filesystem::path outputFilePath(outputFile);
        if (std::filesystem::exists(outputFilePath)) {
            if (!std::filesystem::is_regular_file(outputFilePath))
                fileError(outputFilePath, "already exists but is not a file");
            if (!forceOutputOption.WasSet())
                fileError(outputFilePath, "already exists, use the \"force\" option if you wish to overwrite the file");
        } else {
            std::ofstream outputFileStream(outputFilePath);
            if (outputFileStream.fail()) {
                switch (errno) {
                    case EACCES:
                        fileError(outputFilePath, "is not writable, permission denied");
                        break;
                    default:
                        fileError(outputFilePath, "is not a valid file name");
                        break;
                }
            }
            outputFileStream.close();
            std::filesystem::remove(outputFilePath);
        }
    }
    uint64_t seed = defaultSeed;
    if (seedOption.WasSet()) {
        if (seedOption.GetValue().size() > maxSeedStringSize) {
            std::cout << "Seed string is too long, needs to be at most " << maxSeedStringSize << " characters long";
            exit(EXIT_FAILURE);
        }
        seed = convertToSeed(seedOption.GetValue());
    }
    if (!inputOption.WasSet() && parser.GetPositionalArguments().empty()) {
        std::cout << "No text or file passed, nothing to do\n\n" << parser.HelpText();
        exit(EXIT_SUCCESS);
    }
    if (inputOption.WasSet() && !parser.GetPositionalArguments().empty()) {
        std::cout << "Both a file and plain text were passed at the same time\n\n" << parser.HelpText();
        exit(EXIT_FAILURE);
    }
    std::string textToUwUify;
    if (inputOption.WasSet()) {
        std::filesystem::path inputFile(inputOption.GetValue());
        if (!std::filesystem::exists(inputFile))
            fileError(inputFile, "does not exist");
        if (!std::filesystem::is_regular_file(inputFile))
            fileError(inputFile, "is not a file");
        size_t fileSize = std::filesystem::file_size(inputFile);
        textToUwUify.resize(fileSize);
        std::ifstream fileStream(inputFile);
        fileStream.seekg(0);
        fileStream.read(&textToUwUify[0], fileSize);
        fileStream.close();
    } else {
        size_t argCount = parser.GetPositionalArguments().size();
        size_t reserveAmount = (argCount - 1) * 2; //for adding double newlines between texts.
        for (const auto &arg: parser.GetPositionalArguments())
            reserveAmount += arg.size();
        textToUwUify.reserve(reserveAmount);
        for (size_t i = 0; i < argCount; ++i) {
            textToUwUify += parser.GetPositionalArguments()[i];
            if (argCount > 1 && (i + 1) % argCount != 0)
                textToUwUify += "\n\n";
        }
    }
    return std::make_tuple(textToUwUify, seed, outputFile);
}

int main(int argc, char **argv) {
    auto [textToUwUify, seed, outputFile] = parseArgs(argc, argv);
}
